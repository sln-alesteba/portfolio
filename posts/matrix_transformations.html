<!DOCTYPE html>

<html>
    
    <head>
      
        <meta charset=utf-8>

        <!-- check the post for the entire code https://waloncab.github.io/s.ln_blog/posts/jekyll-build-config.html -->

        <title>Matrix Transformation for Rendering 3D objects-sln-alesteba:blog </title>
          
        <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Matrix Transformation for Rendering 3D objects" />
<meta name="author" content="alesteba" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Transformations are at the core of any rendering engine. Vectors and matrices are the basic data structures that allow to design and create functions to transform set of points in certain geometric way. Points / Vectors / Matrices Both points and vectors are represented by a list of numbers, but they have different geometric interpretations. Points are simple a defined position in a space but vectors represent a direction within that space. Matrices are the best mathematical construct to apply transformations to the points and vectors, GPUs are highly optimized to compute matrix multiplications in parallel. What kind of operations are needed in the 3D space ? Well, in any rendering engine, we require the following: translation rotation scale Keep reding the text and imagine that transformations are applied from the origin of the coordinate system (global coordinates), we&#39;ll consider local transformations later 4x4 Matrix in a 3D Space Homogeneous coordinates are a system of coordinates used in projective geometry. They have the advantage that the coordinates of points, including points at infinity, can be represented using finite coordinates. Since translation is not a linear transformation we need to embed 3x3 matrices in a 4x4 matrices, find out why Basic Transformation Matrices For any given object we need to translate, rotate, and scale. Each one of this scene objects need to store transformation data in a 4x4 matrix. The matrix multiplication allow to easily modify the transformation data the object stores. The following blocks of code create the most basic matrices in numpy arrays. Model Matrix &lt;p&gt; A matrix is used to store the transformation of any object, but what about the points / vertices of that object in the case that it renders some kind of mesh ? &lt;/p&gt; &lt;p&gt;Storing the transformation in the model matrix allows : &lt;/p&gt; &lt;ul&gt; &lt;li&gt;chain transformations by multiplying the model matrix of the object, the result matrix will store the accumulated transformations.&lt;/li&gt; &lt;li&gt;render a complex mesh without having to store the vertices of the mesh inside the object.&lt;/li&gt; &lt;/ul&gt; def init_Identity(): return np.array( [ [1, 0, 0, 0], [0, 1, 0, 0], [0 ,0, 1, 0], [0, 0, 0, 1] ]).astype(float) def init_Translation(x,y,z): return np.array( [ [1, 0, 0, x], [0, 1, 0, y], [0 ,0, 1, z], [0, 0, 0, 1] ]).astype(float) The followings lines of code represent the rotation matrices for the x,y,z axes. Rotation happens around an axis, and the rotation matrix does not move the axis. Rotation can be produced around any vector, but we are considering just the rotation around the basis vectors (axis) since other rotations can be derived later from the world matrix. def init_RotationX(angle): c = cos(angle) s = sin(angle) return np.array( [ [1, 0, 0, 0], [0, c, -s, 0], [0 ,s, c, 0], [0, 0, 0, 1] ]).astype(float) def init_RotationY(angle): c = cos(angle) s = sin(angle) return np.array( [ [ c, 0, s, 0], [ 0, 1, 0, 0], [-s ,0, c, 0], [ 0, 0, 0, 1] ]).astype(float) def init_RotationZ(angle): c = cos(angle) s = sin(angle) return np.array( [ [c, -s, 0, 0], [s, c, 0, 0], [0 ,0, 1, 0], [0, 0, 0, 1] ]).astype(float) This scale matrix only accepts one parameter scaling the object uniformly along the x,y, axes. def init_Scale(s): return np.array( [ [s, 0, 0, 0], [0, s, 0, 0], [0 ,0, s, 0], [0, 0, 0, 1] ]).astype(float) Local vs Global Coordinates When we multiply any of the previous matrices by some point we are transforming that point in a global coordinate system (Origin(0,0,0)). For example, when multiplying a point by the translation matrix the point moves along the basis x,y,z axis. Local transformations require to define an internal local coordinate system. Origin, orientation, and scale of the local coordinate axes are chosen for convenience, but usually the center of the object is selected to transform locally. How to use matrix multiplication to perform transformations in Local Coordinate Systems &lt;p&gt; Let&#39;s keep it simple, in order to perform any global transformation we chain matrix multiplications on the left side of expression. To achieve local transformations just multiply on the right side of the expression. Keep in mind that matrix multiplication is not commutative: A*B != B*A &lt;/p&gt; &lt;ul&gt; &lt;li&gt;Global Transformation: T3 * T2 * T1 * M(model_matrix)&lt;/li&gt; &lt;li&gt;Local Transformation: M(model_matrix) * T1 * T2 * T3&lt;/li&gt; &lt;/ul&gt; Perspective Matrix Perspective matrix for rendering the scene. Frustum: truncated pyramid that defines the visible region. Parameters near / far distance: angle of view: the angle between from and bottom frustum planes. aspect ratio: width / height of the rendered image. def init_Perspective(angleOfView=60, aspectRatio=1, near=0.1, far=1000): #convert to radians a = angleOfView *pi/180 d = 1.0 / tan(a/2) r = aspectRatio b = (far + near) / (near - far) c = 2 * far * near / (near - far) return np.array( [ [d/r, 0, 0, 0], [0, d, 0, 0], [0 ,0, b, c], [0, 0, -1, 0] ]).astype(float) Within the spline context, all this properties allow simple and more complex transformations to take place. Some bezier operations are faster in a matrix form, and whenever a global/local transformation is needed there are matrix multiplications underneath. Check some of the demos to feel the movement." />
<meta property="og:description" content="Transformations are at the core of any rendering engine. Vectors and matrices are the basic data structures that allow to design and create functions to transform set of points in certain geometric way. Points / Vectors / Matrices Both points and vectors are represented by a list of numbers, but they have different geometric interpretations. Points are simple a defined position in a space but vectors represent a direction within that space. Matrices are the best mathematical construct to apply transformations to the points and vectors, GPUs are highly optimized to compute matrix multiplications in parallel. What kind of operations are needed in the 3D space ? Well, in any rendering engine, we require the following: translation rotation scale Keep reding the text and imagine that transformations are applied from the origin of the coordinate system (global coordinates), we&#39;ll consider local transformations later 4x4 Matrix in a 3D Space Homogeneous coordinates are a system of coordinates used in projective geometry. They have the advantage that the coordinates of points, including points at infinity, can be represented using finite coordinates. Since translation is not a linear transformation we need to embed 3x3 matrices in a 4x4 matrices, find out why Basic Transformation Matrices For any given object we need to translate, rotate, and scale. Each one of this scene objects need to store transformation data in a 4x4 matrix. The matrix multiplication allow to easily modify the transformation data the object stores. The following blocks of code create the most basic matrices in numpy arrays. Model Matrix &lt;p&gt; A matrix is used to store the transformation of any object, but what about the points / vertices of that object in the case that it renders some kind of mesh ? &lt;/p&gt; &lt;p&gt;Storing the transformation in the model matrix allows : &lt;/p&gt; &lt;ul&gt; &lt;li&gt;chain transformations by multiplying the model matrix of the object, the result matrix will store the accumulated transformations.&lt;/li&gt; &lt;li&gt;render a complex mesh without having to store the vertices of the mesh inside the object.&lt;/li&gt; &lt;/ul&gt; def init_Identity(): return np.array( [ [1, 0, 0, 0], [0, 1, 0, 0], [0 ,0, 1, 0], [0, 0, 0, 1] ]).astype(float) def init_Translation(x,y,z): return np.array( [ [1, 0, 0, x], [0, 1, 0, y], [0 ,0, 1, z], [0, 0, 0, 1] ]).astype(float) The followings lines of code represent the rotation matrices for the x,y,z axes. Rotation happens around an axis, and the rotation matrix does not move the axis. Rotation can be produced around any vector, but we are considering just the rotation around the basis vectors (axis) since other rotations can be derived later from the world matrix. def init_RotationX(angle): c = cos(angle) s = sin(angle) return np.array( [ [1, 0, 0, 0], [0, c, -s, 0], [0 ,s, c, 0], [0, 0, 0, 1] ]).astype(float) def init_RotationY(angle): c = cos(angle) s = sin(angle) return np.array( [ [ c, 0, s, 0], [ 0, 1, 0, 0], [-s ,0, c, 0], [ 0, 0, 0, 1] ]).astype(float) def init_RotationZ(angle): c = cos(angle) s = sin(angle) return np.array( [ [c, -s, 0, 0], [s, c, 0, 0], [0 ,0, 1, 0], [0, 0, 0, 1] ]).astype(float) This scale matrix only accepts one parameter scaling the object uniformly along the x,y, axes. def init_Scale(s): return np.array( [ [s, 0, 0, 0], [0, s, 0, 0], [0 ,0, s, 0], [0, 0, 0, 1] ]).astype(float) Local vs Global Coordinates When we multiply any of the previous matrices by some point we are transforming that point in a global coordinate system (Origin(0,0,0)). For example, when multiplying a point by the translation matrix the point moves along the basis x,y,z axis. Local transformations require to define an internal local coordinate system. Origin, orientation, and scale of the local coordinate axes are chosen for convenience, but usually the center of the object is selected to transform locally. How to use matrix multiplication to perform transformations in Local Coordinate Systems &lt;p&gt; Let&#39;s keep it simple, in order to perform any global transformation we chain matrix multiplications on the left side of expression. To achieve local transformations just multiply on the right side of the expression. Keep in mind that matrix multiplication is not commutative: A*B != B*A &lt;/p&gt; &lt;ul&gt; &lt;li&gt;Global Transformation: T3 * T2 * T1 * M(model_matrix)&lt;/li&gt; &lt;li&gt;Local Transformation: M(model_matrix) * T1 * T2 * T3&lt;/li&gt; &lt;/ul&gt; Perspective Matrix Perspective matrix for rendering the scene. Frustum: truncated pyramid that defines the visible region. Parameters near / far distance: angle of view: the angle between from and bottom frustum planes. aspect ratio: width / height of the rendered image. def init_Perspective(angleOfView=60, aspectRatio=1, near=0.1, far=1000): #convert to radians a = angleOfView *pi/180 d = 1.0 / tan(a/2) r = aspectRatio b = (far + near) / (near - far) c = 2 * far * near / (near - far) return np.array( [ [d/r, 0, 0, 0], [0, d, 0, 0], [0 ,0, b, c], [0, 0, -1, 0] ]).astype(float) Within the spline context, all this properties allow simple and more complex transformations to take place. Some bezier operations are faster in a matrix form, and whenever a global/local transformation is needed there are matrix multiplications underneath. Check some of the demos to feel the movement." />
<link rel="canonical" href="https://sln-alesteba.github.io/portfolio/portfolio/posts/matrix_transformations.html" />
<meta property="og:url" content="https://sln-alesteba.github.io/portfolio/portfolio/posts/matrix_transformations.html" />
<meta property="og:site_name" content="sln-alesteba:blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-20T11:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Matrix Transformation for Rendering 3D objects" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"alesteba"},"dateModified":"2022-07-20T11:00:00-04:00","datePublished":"2022-07-20T11:00:00-04:00","description":"Transformations are at the core of any rendering engine. Vectors and matrices are the basic data structures that allow to design and create functions to transform set of points in certain geometric way. Points / Vectors / Matrices Both points and vectors are represented by a list of numbers, but they have different geometric interpretations. Points are simple a defined position in a space but vectors represent a direction within that space. Matrices are the best mathematical construct to apply transformations to the points and vectors, GPUs are highly optimized to compute matrix multiplications in parallel. What kind of operations are needed in the 3D space ? Well, in any rendering engine, we require the following: translation rotation scale Keep reding the text and imagine that transformations are applied from the origin of the coordinate system (global coordinates), we&#39;ll consider local transformations later 4x4 Matrix in a 3D Space Homogeneous coordinates are a system of coordinates used in projective geometry. They have the advantage that the coordinates of points, including points at infinity, can be represented using finite coordinates. Since translation is not a linear transformation we need to embed 3x3 matrices in a 4x4 matrices, find out why Basic Transformation Matrices For any given object we need to translate, rotate, and scale. Each one of this scene objects need to store transformation data in a 4x4 matrix. The matrix multiplication allow to easily modify the transformation data the object stores. The following blocks of code create the most basic matrices in numpy arrays. Model Matrix &lt;p&gt; A matrix is used to store the transformation of any object, but what about the points / vertices of that object in the case that it renders some kind of mesh ? &lt;/p&gt; &lt;p&gt;Storing the transformation in the model matrix allows : &lt;/p&gt; &lt;ul&gt; &lt;li&gt;chain transformations by multiplying the model matrix of the object, the result matrix will store the accumulated transformations.&lt;/li&gt; &lt;li&gt;render a complex mesh without having to store the vertices of the mesh inside the object.&lt;/li&gt; &lt;/ul&gt; def init_Identity(): return np.array( [ [1, 0, 0, 0], [0, 1, 0, 0], [0 ,0, 1, 0], [0, 0, 0, 1] ]).astype(float) def init_Translation(x,y,z): return np.array( [ [1, 0, 0, x], [0, 1, 0, y], [0 ,0, 1, z], [0, 0, 0, 1] ]).astype(float) The followings lines of code represent the rotation matrices for the x,y,z axes. Rotation happens around an axis, and the rotation matrix does not move the axis. Rotation can be produced around any vector, but we are considering just the rotation around the basis vectors (axis) since other rotations can be derived later from the world matrix. def init_RotationX(angle): c = cos(angle) s = sin(angle) return np.array( [ [1, 0, 0, 0], [0, c, -s, 0], [0 ,s, c, 0], [0, 0, 0, 1] ]).astype(float) def init_RotationY(angle): c = cos(angle) s = sin(angle) return np.array( [ [ c, 0, s, 0], [ 0, 1, 0, 0], [-s ,0, c, 0], [ 0, 0, 0, 1] ]).astype(float) def init_RotationZ(angle): c = cos(angle) s = sin(angle) return np.array( [ [c, -s, 0, 0], [s, c, 0, 0], [0 ,0, 1, 0], [0, 0, 0, 1] ]).astype(float) This scale matrix only accepts one parameter scaling the object uniformly along the x,y, axes. def init_Scale(s): return np.array( [ [s, 0, 0, 0], [0, s, 0, 0], [0 ,0, s, 0], [0, 0, 0, 1] ]).astype(float) Local vs Global Coordinates When we multiply any of the previous matrices by some point we are transforming that point in a global coordinate system (Origin(0,0,0)). For example, when multiplying a point by the translation matrix the point moves along the basis x,y,z axis. Local transformations require to define an internal local coordinate system. Origin, orientation, and scale of the local coordinate axes are chosen for convenience, but usually the center of the object is selected to transform locally. How to use matrix multiplication to perform transformations in Local Coordinate Systems &lt;p&gt; Let&#39;s keep it simple, in order to perform any global transformation we chain matrix multiplications on the left side of expression. To achieve local transformations just multiply on the right side of the expression. Keep in mind that matrix multiplication is not commutative: A*B != B*A &lt;/p&gt; &lt;ul&gt; &lt;li&gt;Global Transformation: T3 * T2 * T1 * M(model_matrix)&lt;/li&gt; &lt;li&gt;Local Transformation: M(model_matrix) * T1 * T2 * T3&lt;/li&gt; &lt;/ul&gt; Perspective Matrix Perspective matrix for rendering the scene. Frustum: truncated pyramid that defines the visible region. Parameters near / far distance: angle of view: the angle between from and bottom frustum planes. aspect ratio: width / height of the rendered image. def init_Perspective(angleOfView=60, aspectRatio=1, near=0.1, far=1000): #convert to radians a = angleOfView *pi/180 d = 1.0 / tan(a/2) r = aspectRatio b = (far + near) / (near - far) c = 2 * far * near / (near - far) return np.array( [ [d/r, 0, 0, 0], [0, d, 0, 0], [0 ,0, b, c], [0, 0, -1, 0] ]).astype(float) Within the spline context, all this properties allow simple and more complex transformations to take place. Some bezier operations are faster in a matrix form, and whenever a global/local transformation is needed there are matrix multiplications underneath. Check some of the demos to feel the movement.","headline":"Matrix Transformation for Rendering 3D objects","mainEntityOfPage":{"@type":"WebPage","@id":"https://sln-alesteba.github.io/portfolio/portfolio/posts/matrix_transformations.html"},"url":"https://sln-alesteba.github.io/portfolio/portfolio/posts/matrix_transformations.html"}</script>
<!-- End Jekyll SEO tag -->


        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/body.css">
        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/tags.css">

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-GP7FZ2055V"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-GP7FZ2055V');
        </script>

        <!-- FAVICONS -->

        <link rel="apple-touch-icon" sizes="180x180" href="https://sln-alesteba.github.io/portfolio/assets/fav/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="https://sln-alesteba.github.io/portfolio/assets/fav/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://sln-alesteba.github.io/portfolio/assets/fav/favicon-16x16.png">
        <link rel="manifest" href="https://sln-alesteba.github.io/portfolio/assets/fav/site.webmanifest">
        <link rel="mask-icon" href="https://sln-alesteba.github.io/portfolio/assets/fav/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="theme-color" content="#ffffff">

    </head>

    <body>

        <div class="content">

            <!-- <div class="header">
         
    <h1>sln-alesteba:blog</h1>

    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/social.css">
    <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/header.css">

    <meta name="viewport" content="width=device-width, initial-scale=1"> 
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.6.js"></script> 


    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
        "imports": {
        "three": "https://unpkg.com/three/build/three.module.js"
        }
    } 
    </script>

    <p>
        <a href="https://www.youtube.com/channel/UCJX8AUDFcQJMjY1zRivvZqw" class="fa fa-youtube"></a>
        <a href="https://www.instagram.com/sln-alesteba/" class="fa fa-instagram"></a>
        <a href="https://www.instagram.com/walon_cab/" class="fa fa-facebook"></a>
        <a href="https://twitter.com/WalonCab" class="fa fa-twitter"></a>
    </p>

</div>  -->


<div class="header">

    <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/demos.css">

    <div class="grid-container_demo">

        <div class="item_demo_1">
        
            <!-- <img src="https://img.youtube.com/vi/HO34GNlTT1E/mqdefault.jpg" alt="icon" height="113" width="200"> -->

            <img src="https://sln-alesteba.github.io/portfolio/assets/img/cv.PNG"  width= "100%" height="160"alt="icon">

        </div>
        
        <div class="itemAA_demo_2">

            <p>
                My name is Alberto Esteban, I'm from Logroño, La Rioja a small city in northern Spain. 
                I'm software engineer currently studying a masters in Data Science. 
                I've always been very curious about coding and I've developed a special interest in computer graphics. 
                Right now I'm focusing on learning new things about machine and deep learning, especially from the data architecture perspective.
                (because I belive is pretty similar to the rendering engine pipelines I now.)
            </p>

            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

            <p align="center">
 
                <a href="https://www.youtube.com/channel/UCJX8AUDFcQJMjY1zRivvZqw" class="button"><i class="fa fa-youtube-play" style="font-size:24px"></i></a>
                <a href="https://www.instagram.com/walon_cab/" class="button"><i class="fa fa-instagram" style="font-size:24px"></i></a>
                <a href="https://github.com/waloncab" class="button"><i class="fa fa-github" style="font-size:24px"></i></a>
                <a href="https://huggingface.co/" class="button"><i class="fa fa-area-chart" style="font-size:24px"></i></a>

            </p>
        
        </div>

    </div>

</div>

            <br>
            
            <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/navigation.css">

<!-- https://www.w3schools.com/howto/howto_js_topnav_responsive.asp -->

<div class="topnav" id="myTopnav">

    <!-- <a href="https://sln-alesteba.github.io/portfolio/index.html" class="active">Blog</a>
    <a href="https://sln-alesteba.github.io/portfolio/about">About</a>
    <a href="https://sln-alesteba.github.io/portfolio/demos">Demos</a> -->

    <!-- <ul> -->

        
        
        <a href="https://sln-alesteba.github.io/portfolio/about/">About</a><a href="https://sln-alesteba.github.io/portfolio/blog/">Blog</a><a href="https://sln-alesteba.github.io/portfolio/demos/">Demos</a><a href="https://sln-alesteba.github.io/portfolio/projects/">Projects</a>

    <!-- </ul> -->

    <div class="search-container">

        
        <!-- <form action="/action_page.php">
          <input type="text" placeholder="Search.." name="search">
          <button type="submit">Submit</button>
        </form> -->

        <form action='https://sln-alesteba.github.io/portfolio/search.html' method="get">
            <input type="text" id="search-box" name="query">
            <!-- <input type="submit" value="search"> -->
            <button type="submit" value="search">Submit</button>
        </form>
    </div>

    <a href="javascript:void(0);" class="icon" onclick="myFunction()">
      <i class="fa fa-bars"></i>
    </a>

</div>

<script>
    /* Toggle between adding and removing the "responsive" class to topnav when the user clicks on the icon */
    function myFunction() {
        var x = document.getElementById("myTopnav");
        if (x.className === "topnav") {
            x.className += " responsive";
        } else {
            x.className = "topnav";
        }
    }
</script>

            <br>

            <!-- SUPPORT FOR JUPYTER NOTEBOOKS -->

<link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/notebook.css">
<link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/colorful.css">

<!-- SUPPORT FOR LATEX -->

<script
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
type="text/javascript">
</script>

<div class="tag-container">

    <h1>Matrix Transformation for Rendering 3D objects</h1>

    <hr>

    <div class="option-line">
    
        

    </div>

</div>

<hr>

<!-- <h3> Matrix Transformations & Rendering 3D</h3> -->

<p>
    Transformations are at the core of any rendering engine. 
    Vectors and matrices are the basic data structures that allow to
    design and create functions to transform set of points in certain geometric way.
</p>

<h3> Points / Vectors / Matrices</h3>
<p>
    Both points and vectors are represented by a list of numbers, but they have different geometric interpretations.
    Points are simple a defined position in a space but vectors represent a direction within that space.
    Matrices are the best mathematical construct to apply transformations to the points and vectors, GPUs are highly optimized
    to compute matrix multiplications in parallel.
</p>

<h3> What kind of operations are needed in the 3D space ? </h3>

<p>Well, in any rendering engine, we require the following:</p>

<ul>
    <li>translation</li>
    <li>rotation</li>
    <li>scale</li>
</ul>

<p> Keep reding the text and imagine that transformations are applied from the origin of the coordinate system (global coordinates), 
    we'll consider local transformations later  </p>

<h3>4x4 Matrix in a 3D Space</h3>

<p> <a href="https://en.wikipedia.org/wiki/Homogeneous_coordinates">Homogeneous coordinates</a> are a system of coordinates used in projective geometry.
    They have the advantage that the coordinates of points, including points at infinity, can be represented using finite coordinates.
    Since translation is not a linear transformation we need to embed 3x3 matrices in a 4x4 matrices, <a href="https://en.wikipedia.org/wiki/Translation_(geometry)">find out why</a>
</p>

<h3> Basic Transformation Matrices</h3>

<p>
For any given object we need to translate, rotate, and scale. Each one of this scene objects need to store transformation data in a 4x4 matrix. 
The matrix multiplication allow to easily modify the transformation data the object stores.
The following blocks of code create the most basic matrices in numpy arrays.
</p>

<h3>Model Matrix</h3>

    <p>
    A matrix is used to store the transformation of any object, but what about the points / vertices of that object in the case that 
    it renders some kind of mesh ?
    </p>

    <p>Storing the transformation in the model matrix allows : </p>

    <ul>
        <li>chain transformations by multiplying the model matrix of the object, the result matrix will store the accumulated transformations.</li>
        <li>render a complex mesh without having to store the vertices of the mesh inside the object.</li>
    </ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">init_Identity</span><span class="p">():</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">]).</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></code></pre></figure>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">init_Translation</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">]).</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></code></pre></figure>

<p>
    The followings lines of code represent the rotation matrices for the x,y,z axes.
    Rotation happens around an axis, and the rotation matrix does not move the axis.
    Rotation can be produced around any vector, but we are considering just the rotation around the 
    basis vectors (axis) since other rotations can be derived later from the world matrix.
</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">init_RotationX</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span>
        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span> <span class="p">,</span><span class="n">s</span><span class="p">,</span>  <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>  <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">]).</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">init_RotationY</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span>
        <span class="p">[</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="o">-</span><span class="n">s</span> <span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">]).</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">init_RotationZ</span><span class="p">(</span><span class="n">angle</span><span class="p">):</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">c</span><span class="p">,</span> <span class="o">-</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">]).</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></code></pre></figure>

<p>
    This scale matrix only accepts one parameter scaling the object uniformly along the x,y, axes.
</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">init_Scale</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
    <span class="p">]).</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></code></pre></figure>

<h3> Local vs Global Coordinates </h3>

<p>
    When we multiply any of the previous matrices by some point we are transforming that point in a global coordinate system (Origin(0,0,0)). 
    For example, when multiplying a point by the translation matrix the point moves along the basis x,y,z axis.
    Local transformations require to define an internal local coordinate system. Origin, orientation, and scale of the
    local coordinate axes are chosen for convenience, but usually the center of the object is selected to transform locally.
</p>

<h3> How to use matrix multiplication to perform transformations in Local Coordinate Systems </h3>

    <p>
        Let's keep it simple, in order to perform any global transformation we chain matrix multiplications on the left side of expression.
        To achieve local transformations just multiply on the right side of the expression. 
        Keep in mind that matrix multiplication is not commutative: A*B != B*A 
    </p>

    <ul>
        <li>Global Transformation: T3 * T2 * T1 * M(model_matrix)</li>
        <li>Local Transformation: M(model_matrix) * T1 * T2 * T3</li>
    </ul>

<h3> Perspective Matrix </h3>

<p>
    Perspective matrix for rendering the scene.
</p>

<ul>
    <li>Frustum: truncated pyramid that defines the visible region.</li>
    <li>Parameters</li>
    <ul>
        <li>near / far distance: </li>
        <li>angle of view: the angle between from and bottom frustum planes.</li>
        <li>aspect ratio: width / height of the rendered image.</li>
    </ul>
</ul>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">init_Perspective</span><span class="p">(</span><span class="n">angleOfView</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">aspectRatio</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">near</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">far</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>

    <span class="c1">#convert to radians
</span>    <span class="n">a</span> <span class="o">=</span> <span class="n">angleOfView</span> <span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">tan</span><span class="p">(</span><span class="n">a</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">aspectRatio</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="n">far</span> <span class="o">+</span> <span class="n">near</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">near</span> <span class="o">-</span> <span class="n">far</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span>  <span class="mi">2</span> <span class="o">*</span> <span class="n">far</span> <span class="o">*</span> <span class="n">near</span> <span class="o">/</span> <span class="p">(</span><span class="n">near</span> <span class="o">-</span> <span class="n">far</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">(</span> <span class="p">[</span>
        <span class="p">[</span><span class="n">d</span><span class="o">/</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span> <span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">],</span>
        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="p">]).</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span></code></pre></figure>

<p>
    Within the spline context, all this properties allow simple and more complex transformations to take place.
    Some bezier operations are faster in a matrix form, and whenever a global/local transformation is needed there are matrix multiplications underneath.
    Check some of the demos to feel the movement.
</p>

<!-- INCLUDE spline / procedural -->





<!-- RELATED POSTS -->
<!-- añadir some text here, tener en cuenta cómo diseñar -->
<!-- <h3>Related Posts</h3> --> -->



<div class="child">

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/STIFF_image.html">STIF image classifier</a>
    <p>2023-07-24 19:00:01 -0400</p>
    <p>2023-07-25-STIFF_image In [1]: import cv2 as cv2 In [2]: %%capture ! pip install -U "ray[default]" ! pip install bing-image-downloader In [3]: import ray In [4]: context = ray.init() print(context.dashboard_url) 2023-06-11 12:18:14,277 INFO worker.py:1627 -- Started a local Ray instance. View the dashboard at 127.0.0.1:8265 127.0.0.1:8265 In this blog post we'll implement an image classification...</p>
</div>
            
        <br>

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/2_bezier_MAT.html">Bezier Matrix</a>
    <p>2023-07-23 19:00:01 -0400</p>
    <p>2023-07-24-2_bezier_MAT In [1]: import scipy.special import numpy as np In this final notebook, we are going to compute the Bézier curves as matrix operations. This approach will make it easier to accelerate the computation, since matrix operations can be easily implemented as CUDA kernels. We'll start by writing the general Bézier...</p>
</div>
            
        <br>

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/1_bezier_CUDA.html">Bezier CUDA</a>
    <p>2023-07-23 19:00:01 -0400</p>
    <p>2023-07-24-1_bezier_CUDA Bézier curves are polynomials of t, they can be implemented using simple polynomials. When a new control point is introduced the curve degree increases making the computational cost rise exponentially. The following code will implement a general method to test n-control points and n-dimension curves. Take a look at...</p>
</div>
            
        <br>

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/0_bezier_PLL.html">Bezier Parallel</a>
    <p>2023-07-23 19:00:01 -0400</p>
    <p>2023-07-24-0_bezier_PLL Introduction¶ In this publication, we are going to understand how general Bézier curves are created, and we'll implement different parallel algorithms to make them run faster. The aim of this post is to handle general curves, that means that we need the mathematical tools to create them. You may...</p>
</div>
            
        <br>

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/NeRF_ficus.html">NeRF - A concrete example, Ficus</a>
    <p>2023-04-05 18:00:00 -0400</p>
    <p> 
	NeRF proposes an ingenious way to synthesize novel views of a scene by modelling the volumetric scene function through a neural network. 
	The network learns to model the volumetric scene, thus generating novel views (images) of the 3D scene that the model was not shown at training time.


</p>
</div>
            
        <br>

    

</div>

            <br>

            <div class="footer">

    <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/rotate.css">
    <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/footer.css">

    <div class="grid-container-footer">

        <div class="item1" id="rotator">
            <img src="https://sln-alesteba.github.io/portfolio/assets/img/fire_buble.png" alt="Walon Cab" width="128" height="128" align="center" class="rotate">
        </div>

        <div class="item2">
            <p class="right">Graphics rendering and spline algorithms. Kinematics from the bezier curves by  traversing generated paths, using some data science techniques and algorithms to enhance the process. Stay tunned for the Spline Lab!</p>

            <p align="center">
                &copy; 2023 alesteba
            </p>
        </div>

        <div class="item3">
            <p>
                Check out some of the resources out there! You'll find graphics, 
                splines, kinematics and code !
            </p>

            <p align="center">
                <a href="https://www.youtube.com/channel/UCJX8AUDFcQJMjY1zRivvZqw" class="fa fa-youtube"></a>
                <a href="https://www.instagram.com/sln-alesteba/" class="fa fa-instagram"></a>
                <a href="https://www.instagram.com/sln-alesteba/" class="fa fa-facebook"></a>
                <a href="https://twitter.com/WalonCab" class="fa fa-twitter"></a>
            </p>
        </div>  
    </div>
</div>

        </div>

    </body>

</html> 