<!DOCTYPE html>

<html>
    
    <head>
      
        <meta charset=utf-8>

        <!-- check the post for the entire code https://waloncab.github.io/s.ln_blog/posts/jekyll-build-config.html -->

        <title>Rendering Engine Architecture-sln-alesteba:blog </title>
          
        <!-- Begin Jekyll SEO tag v2.8.0 -->
<meta name="generator" content="Jekyll v4.2.2" />
<meta property="og:title" content="Rendering Engine Architecture" />
<meta name="author" content="waloncab" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Graphics Library vs Rendering Engine OpenGL is a graphics library with many functions for drawing complex geometries based on more simple geometry primitives such as points, lines and triangles. A rendering engine is a well defined framework that uses some of the graphics library functions to deliver a simple way to construct 3d scenes. In order to understand the rendering engine architecture, lets have a grasp of what a graphics pipeline looks like. Graphics Pipeline The graphics pipeline is the process of turning a 3D model into what the computer displays in the 2D screen. The pipeline has the following stages: application: is executed by the software on the main processor, the CPU, initializing the window where graphics will be displayed during the following steps. geometry: determining the position of each vertex of the geometric shapes that need to be rendered, implemented by a program called a vertex shader. rasterization: establish the relationship between screen pixels and geometric shapes. It is responsible for the majority of the operations with polygons and their vertices It can be divided in the following steps: [start] in: object coordinates Model &amp; Camera transformations: Lighting Projection Clipping Window - view port transformation [end] out: device (screen) coordinates pixel processing: associates each pixel in the render image with a color, involves a program called fragment shader. Scene Tree Prior to any of the rendering steps mentioned before, the rendering engine has to work with some abstract representation of a 3D-scene. This scene is sometimes structured as a tree since it’s simple to calculate complex transformations applied to object hierarchies. Within this hierarchy each of the 3D objects must store the following data: matrix for its local transformation lis of references to child objects reference to a parent object Notice that within the same class, a full tree structure has beend defined. Some of the functions this ‘gameObject’ class needs to have are: add / remove to manage child / parent objects worldMatrix to calculate the global position getChildren to convert the scene tree to a list With this simple ingridients the tree structure the 3D scene can easily be rendered mantaining each object position relative to parent / child. Keep in mind that the model matrix (matrix for local transformation) can accumulate the result of many transformations, this transformations apply to the hierarchy of parent and children. Model Matrix It stores the current location, orientation and scale of a ‘gameObject’. The aculmulated transformations end up stored within the matrix data. Why is so important? The global positions of any of the mesh vertices that may actually be rendered won’t be stored, they are calculated based on the object model matrix every frame when they need to be rendered on screen. Have a look at the diferent matrices operations that can take within the object local / global transformations: Matrix Transformations for Rendering 3D Objects When transforming a set of points with a matrix: points are multiplied by the matrix in the vertex shader new coordinates are passed along to the fragment shader new coordinates of the points are not permantently stored" />
<meta property="og:description" content="Graphics Library vs Rendering Engine OpenGL is a graphics library with many functions for drawing complex geometries based on more simple geometry primitives such as points, lines and triangles. A rendering engine is a well defined framework that uses some of the graphics library functions to deliver a simple way to construct 3d scenes. In order to understand the rendering engine architecture, lets have a grasp of what a graphics pipeline looks like. Graphics Pipeline The graphics pipeline is the process of turning a 3D model into what the computer displays in the 2D screen. The pipeline has the following stages: application: is executed by the software on the main processor, the CPU, initializing the window where graphics will be displayed during the following steps. geometry: determining the position of each vertex of the geometric shapes that need to be rendered, implemented by a program called a vertex shader. rasterization: establish the relationship between screen pixels and geometric shapes. It is responsible for the majority of the operations with polygons and their vertices It can be divided in the following steps: [start] in: object coordinates Model &amp; Camera transformations: Lighting Projection Clipping Window - view port transformation [end] out: device (screen) coordinates pixel processing: associates each pixel in the render image with a color, involves a program called fragment shader. Scene Tree Prior to any of the rendering steps mentioned before, the rendering engine has to work with some abstract representation of a 3D-scene. This scene is sometimes structured as a tree since it’s simple to calculate complex transformations applied to object hierarchies. Within this hierarchy each of the 3D objects must store the following data: matrix for its local transformation lis of references to child objects reference to a parent object Notice that within the same class, a full tree structure has beend defined. Some of the functions this ‘gameObject’ class needs to have are: add / remove to manage child / parent objects worldMatrix to calculate the global position getChildren to convert the scene tree to a list With this simple ingridients the tree structure the 3D scene can easily be rendered mantaining each object position relative to parent / child. Keep in mind that the model matrix (matrix for local transformation) can accumulate the result of many transformations, this transformations apply to the hierarchy of parent and children. Model Matrix It stores the current location, orientation and scale of a ‘gameObject’. The aculmulated transformations end up stored within the matrix data. Why is so important? The global positions of any of the mesh vertices that may actually be rendered won’t be stored, they are calculated based on the object model matrix every frame when they need to be rendered on screen. Have a look at the diferent matrices operations that can take within the object local / global transformations: Matrix Transformations for Rendering 3D Objects When transforming a set of points with a matrix: points are multiplied by the matrix in the vertex shader new coordinates are passed along to the fragment shader new coordinates of the points are not permantently stored" />
<link rel="canonical" href="https://sln-alesteba.github.io/portfolio/portfolio/posts/rendering_engine_architecture.html" />
<meta property="og:url" content="https://sln-alesteba.github.io/portfolio/portfolio/posts/rendering_engine_architecture.html" />
<meta property="og:site_name" content="sln-alesteba:blog" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2022-07-20T11:00:00-04:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Rendering Engine Architecture" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"waloncab"},"dateModified":"2022-07-20T11:00:00-04:00","datePublished":"2022-07-20T11:00:00-04:00","description":"Graphics Library vs Rendering Engine OpenGL is a graphics library with many functions for drawing complex geometries based on more simple geometry primitives such as points, lines and triangles. A rendering engine is a well defined framework that uses some of the graphics library functions to deliver a simple way to construct 3d scenes. In order to understand the rendering engine architecture, lets have a grasp of what a graphics pipeline looks like. Graphics Pipeline The graphics pipeline is the process of turning a 3D model into what the computer displays in the 2D screen. The pipeline has the following stages: application: is executed by the software on the main processor, the CPU, initializing the window where graphics will be displayed during the following steps. geometry: determining the position of each vertex of the geometric shapes that need to be rendered, implemented by a program called a vertex shader. rasterization: establish the relationship between screen pixels and geometric shapes. It is responsible for the majority of the operations with polygons and their vertices It can be divided in the following steps: [start] in: object coordinates Model &amp; Camera transformations: Lighting Projection Clipping Window - view port transformation [end] out: device (screen) coordinates pixel processing: associates each pixel in the render image with a color, involves a program called fragment shader. Scene Tree Prior to any of the rendering steps mentioned before, the rendering engine has to work with some abstract representation of a 3D-scene. This scene is sometimes structured as a tree since it’s simple to calculate complex transformations applied to object hierarchies. Within this hierarchy each of the 3D objects must store the following data: matrix for its local transformation lis of references to child objects reference to a parent object Notice that within the same class, a full tree structure has beend defined. Some of the functions this ‘gameObject’ class needs to have are: add / remove to manage child / parent objects worldMatrix to calculate the global position getChildren to convert the scene tree to a list With this simple ingridients the tree structure the 3D scene can easily be rendered mantaining each object position relative to parent / child. Keep in mind that the model matrix (matrix for local transformation) can accumulate the result of many transformations, this transformations apply to the hierarchy of parent and children. Model Matrix It stores the current location, orientation and scale of a ‘gameObject’. The aculmulated transformations end up stored within the matrix data. Why is so important? The global positions of any of the mesh vertices that may actually be rendered won’t be stored, they are calculated based on the object model matrix every frame when they need to be rendered on screen. Have a look at the diferent matrices operations that can take within the object local / global transformations: Matrix Transformations for Rendering 3D Objects When transforming a set of points with a matrix: points are multiplied by the matrix in the vertex shader new coordinates are passed along to the fragment shader new coordinates of the points are not permantently stored","headline":"Rendering Engine Architecture","mainEntityOfPage":{"@type":"WebPage","@id":"https://sln-alesteba.github.io/portfolio/portfolio/posts/rendering_engine_architecture.html"},"url":"https://sln-alesteba.github.io/portfolio/portfolio/posts/rendering_engine_architecture.html"}</script>
<!-- End Jekyll SEO tag -->


        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/body.css">
        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/table.css">

        <!-- Global site tag (gtag.js) - Google Analytics -->
        <script async src="https://www.googletagmanager.com/gtag/js?id=G-GP7FZ2055V"></script>
        <script>
            window.dataLayer = window.dataLayer || [];
            function gtag(){dataLayer.push(arguments);}
            gtag('js', new Date());

            gtag('config', 'G-GP7FZ2055V');
        </script>

        <!-- FAVICONS -->

        <link rel="apple-touch-icon" sizes="180x180" href="https://sln-alesteba.github.io/portfolio/assets/fav/apple-touch-icon.png">
        <link rel="icon" type="image/png" sizes="32x32" href="https://sln-alesteba.github.io/portfolio/assets/fav/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://sln-alesteba.github.io/portfolio/assets/fav/favicon-16x16.png">
        <link rel="manifest" href="https://sln-alesteba.github.io/portfolio/assets/fav/site.webmanifest">
        <link rel="mask-icon" href="https://sln-alesteba.github.io/portfolio/assets/fav/safari-pinned-tab.svg" color="#5bbad5">
        <meta name="msapplication-TileColor" content="#da532c">
        <meta name="theme-color" content="#ffffff">

    </head>

    <body>

        <div class="content">

            <div class="header">
         
    <h1>sln-alesteba:blog</h1>

    <!-- Add icon library -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/social.css">
    <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/header.css">

    <meta name="viewport" content="width=device-width, initial-scale=1"> 
    <script type="text/javascript" src="https://code.jquery.com/jquery-1.6.js"></script> 


    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

    <script type="importmap">
    {
        "imports": {
        "three": "https://unpkg.com/three/build/three.module.js"
        }
    }
    </script>

    <p>
        <a href="https://www.youtube.com/channel/UCJX8AUDFcQJMjY1zRivvZqw" class="fa fa-youtube"></a>
        <a href="https://www.instagram.com/sln-alesteba/" class="fa fa-instagram"></a>
        <a href="https://www.instagram.com/walon_cab/" class="fa fa-facebook"></a>
        <a href="https://twitter.com/WalonCab" class="fa fa-twitter"></a>
    </p>

</div> 

            <br>
            
            <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/nav.css">

<!-- https://www.w3schools.com/howto/howto_js_topnav_responsive.asp -->

<div class="topnav" id="myTopnav">

    <!-- <a href="https://sln-alesteba.github.io/portfolio/index.html" class="active">Blog</a>
    <a href="https://sln-alesteba.github.io/portfolio/about">About</a>
    <a href="https://sln-alesteba.github.io/portfolio/demos">Demos</a> -->

    <!-- <ul> -->

        
        
        <a href="https://sln-alesteba.github.io/portfolio/about/">About</a><a href="https://sln-alesteba.github.io/portfolio/blog/">Blog</a><a href="https://sln-alesteba.github.io/portfolio/demos/">Demos</a><a href="https://sln-alesteba.github.io/portfolio/projects/">Projects</a>

    <!-- </ul> -->

    <div class="search-container">

        
        <!-- <form action="/action_page.php">
          <input type="text" placeholder="Search.." name="search">
          <button type="submit">Submit</button>
        </form> -->

        <form action='https://sln-alesteba.github.io/portfolio/search.html' method="get">
            <input type="text" id="search-box" name="query">
            <!-- <input type="submit" value="search"> -->
            <button type="submit" value="search">Submit</button>
        </form>
    </div>

    <a href="javascript:void(0);" class="icon" onclick="myFunction()">
      <i class="fa fa-bars"></i>
    </a>

</div>

<script>
    /* Toggle between adding and removing the "responsive" class to topnav when the user clicks on the icon */
    function myFunction() {
        var x = document.getElementById("myTopnav");
        if (x.className === "topnav") {
            x.className += " responsive";
        } else {
            x.className = "topnav";
        }
    }
</script>

            <br>

            <!-- SUPPORT FOR JUPYTER NOTEBOOKS -->

<link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/notebook.css">
<link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/colorful.css">

<!-- SUPPORT FOR LATEX -->

<script
src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"
type="text/javascript">
</script>


<h1>Rendering Engine Architecture</h1>

<!-- PAGE CATEGORIES -->

<hr>



    <button type="button" 
            onclick="window.location.href='https://sln-alesteba.github.io/portfolio/search.html?query=blog';">
        blog
    </button> 



    <button type="button" 
            onclick="window.location.href='https://sln-alesteba.github.io/portfolio/search.html?query=rendering';">
        rendering
    </button> 



    <button type="button" 
            onclick="window.location.href='https://sln-alesteba.github.io/portfolio/search.html?query=graphics';">
        graphics
    </button> 



    <button type="button" 
            onclick="window.location.href='https://sln-alesteba.github.io/portfolio/search.html?query=architecture';">
        architecture
    </button> 



<hr>

<ul>
  <li>
    <p>Graphics Library vs Rendering Engine</p>

    <p>OpenGL is a graphics library with many functions for drawing complex geometries based on more simple geometry primitives such as points, lines and triangles. 
  A rendering engine is a well defined framework that uses some of the graphics library functions to deliver a simple way to construct 3d scenes. 
  In order to understand the rendering engine architecture, lets have a grasp of what a graphics pipeline looks like.</p>
  </li>
  <li>
    <p>Graphics Pipeline</p>

    <p>The graphics pipeline is the process of turning a 3D model into what the computer displays in the 2D screen.
  The pipeline has the following stages:</p>

    <ul>
      <li>
        <p>application: is executed by the software on the main processor, the CPU, initializing the window where graphics will be displayed during the following steps.</p>
      </li>
      <li>
        <p>geometry: determining the position of each vertex of the geometric shapes that need to be rendered, implemented by a program called a vertex shader.</p>
      </li>
      <li>
        <p>rasterization: establish the relationship between screen pixels and geometric shapes. It is responsible for the majority of the operations with polygons and their vertices</p>

        <p>It can be divided in the following steps:</p>
        <ul>
          <li>[start] in: object coordinates</li>
          <li>Model &amp; Camera transformations:</li>
          <li>Lighting</li>
          <li>Projection</li>
          <li>Clipping</li>
          <li>Window - view port transformation</li>
          <li>[end] out: device (screen) coordinates</li>
        </ul>
      </li>
      <li>
        <p>pixel processing: associates each pixel in the render image with a color, involves a program called fragment shader.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Scene Tree</p>

    <p>Prior to any of the rendering steps mentioned before, the rendering engine has to work with some abstract representation of a 3D-scene.
  This scene is sometimes structured as a tree since it’s simple to calculate complex transformations applied to object hierarchies.</p>

    <p>Within this hierarchy each of the 3D objects must store the following data:</p>
    <ul>
      <li>matrix for its local transformation</li>
      <li>lis of references to child objects</li>
      <li>reference to a parent object</li>
    </ul>

    <p>Notice that within the same class, a full tree structure has beend defined. Some of the functions this ‘gameObject’ class needs to have are:</p>
    <ul>
      <li>add / remove to manage child / parent objects</li>
      <li>worldMatrix to calculate the global position</li>
      <li>getChildren to convert the scene tree to a list</li>
    </ul>

    <p>With this simple ingridients the tree structure the 3D scene can easily be rendered mantaining each object position relative to parent / child.
  Keep in mind that the model matrix (matrix for local transformation) can accumulate the result of many transformations, 
  this transformations apply to the hierarchy of parent and children.</p>
  </li>
  <li>
    <p>Model Matrix</p>

    <p>It stores the current location, orientation and scale of a ‘gameObject’. The aculmulated transformations end up stored within the matrix data.
  Why is so important? The global positions of any of the mesh vertices that may actually be rendered won’t be stored,
  they are calculated based on the object model matrix every frame when they need to be rendered on screen.
  Have a look at the diferent matrices operations that can take within the object local / global transformations:
  <a href="https://waloncab.github.io/s.ln_blog/posts/matrix_transformations.html">Matrix Transformations for Rendering 3D Objects</a></p>

    <p>When transforming a set of points with a matrix:</p>
    <ul>
      <li>points are multiplied by the matrix in the vertex shader</li>
      <li>new coordinates are passed along to the fragment shader</li>
      <li>new coordinates of the points are not permantently stored</li>
    </ul>
  </li>
</ul>



<!-- INCLUDE spline / procedural -->





<!-- RELATED POSTS -->

<h3>Related Posts</h3>



<div class="child">

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/NeRF_ficus.html">NeRF - A concrete example, Ficus</a>
    <p>2023-04-05 18:00:00 -0400</p>
    <p> explicación inicial, hace falta algo de texto 

</p>
</div>
            
        <br>

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/LOF-outlier-pipeline.html">LOF Outlier Imblearn Pipeline</a>
    <p>2023-03-04 17:00:00 -0500</p>
    <p>2023-03-11-LOF-outlier-pipeline In this post we examine how to append a local outlier factor method to a regular pipeline, but using imblearn ones. Lets review how to use pipelines when the shape of the dataset need to be modified, such as with outlier removal. In&nbsp;[17]: import pandas as pd import numpy...</p>
</div>
            
        <br>

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/polinomial-iterpolation.html">Polynomial Interpolation</a>
    <p>2023-03-04 17:00:00 -0500</p>
    <p>2023-03-04-polinomial-iterpolation Since many of the things that we do in the blog are about splines, in this post we're going to cover how to fit polynomials and splines to random scatter points. We'll use some of the basic scikit-learn functionality to avoid implementing the polynomial transformations from scratch. In this...</p>
</div>
            
        <br>

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/jekyll-build-config.html">Jekyll Build Config</a>
    <p>2022-12-18 19:00:00 -0500</p>
    <p>Jekyll is a powerfull tool for building static websites. Simple integration with github-pages, fast building process, multiple plug-ins to extend functionality, are some of the core features that makes it great. Let's see different techniques to create a solid webpage and speed-up the build process. # markdwon Markdown is a...</p>
</div>
            
        <br>

    

        <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/post.css">

<div class="post">
    <a href="https://sln-alesteba.github.io/portfolio/posts/django-jupyter-notebook.html">Django + Jupyter Notebooks</a>
    <p>2022-12-16 19:00:00 -0500</p>
    <p>In this post we explore how to combine the django framework with jupyter notebooks. Sometimes this way of executing code from within the app can be very usuful to test our models. The following code must be executed in the first cell of each notebook. {% highlight python %} #...</p>
</div>
            
        <br>

    

</div>

            <br>

            <div class="footer">

    <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/rotate.css">
    <link rel="stylesheet" href="https://sln-alesteba.github.io/portfolio/assets/css/footer.css">

    <div class="grid-container">

        <div class="item1" id="rotator">
            <img src="https://sln-alesteba.github.io/portfolio/assets/img/fire_buble.png" alt="Walon Cab" width="128" height="128" align="center" class="rotate">
        </div>

        <div class="item2">
            <p class="right">Graphics rendering and spline algorithms. Kinematics from the bezier curves by  traversing generated paths, using some data science techniques and algorithms to enhance the process. Stay tunned for the Spline Lab!</p>

            <p align="center">
                &copy; 2023 alesteba
            </p>
        </div>

        <div class="item3">
            <p>
                Check out some of the resources out there! You'll find graphics, 
                splines, kinematics and code !
            </p>

            <p align="center">
                <a href="https://www.youtube.com/channel/UCJX8AUDFcQJMjY1zRivvZqw" class="fa fa-youtube"></a>
                <a href="https://www.instagram.com/waloncab/" class="fa fa-instagram"></a>
                <a href="https://www.instagram.com/waloncab/" class="fa fa-facebook"></a>
                <a href="https://twitter.com/WalonCab" class="fa fa-twitter"></a>
            </p>
        </div>  

      </div>

</div>

        </div>

    </body>

</html> 